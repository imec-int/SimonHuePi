0 info it worked if it ends with ok
1 verbose cli [ 'node', '/usr/local/bin/npm', 'install', 'onoff' ]
2 info using npm@1.3.2
3 info using node@v0.10.13
4 verbose readDependencies using package.json deps
5 verbose cache add [ 'onoff', null ]
6 verbose cache add name=undefined spec="onoff" args=["onoff",null]
7 verbose parsed url { protocol: null,
7 verbose parsed url   slashes: null,
7 verbose parsed url   auth: null,
7 verbose parsed url   host: null,
7 verbose parsed url   port: null,
7 verbose parsed url   hostname: null,
7 verbose parsed url   hash: null,
7 verbose parsed url   search: null,
7 verbose parsed url   query: null,
7 verbose parsed url   pathname: 'onoff',
7 verbose parsed url   path: 'onoff',
7 verbose parsed url   href: 'onoff' }
8 silly lockFile 1e5d8f47-onoff onoff
9 verbose lock onoff /Users/robbiewauters/.npm/1e5d8f47-onoff.lock
10 silly lockFile 1e5d8f47-onoff onoff
11 silly lockFile 1e5d8f47-onoff onoff
12 verbose addNamed [ 'onoff', '' ]
13 verbose addNamed [ null, '*' ]
14 silly lockFile 0e81c0d2-onoff onoff@
15 verbose lock onoff@ /Users/robbiewauters/.npm/0e81c0d2-onoff.lock
16 silly addNameRange { name: 'onoff', range: '*', hasData: false }
17 verbose url raw onoff
18 verbose url resolving [ 'https://registry.npmjs.org/', './onoff' ]
19 verbose url resolved https://registry.npmjs.org/onoff
20 info trying registry request attempt 1 at 02:35:31
21 verbose etag "3IA0X8G22IP4MMXZ8J20SXA7A"
22 http GET https://registry.npmjs.org/onoff
23 http 304 https://registry.npmjs.org/onoff
24 silly registry.get cb [ 304,
24 silly registry.get   { server: 'CouchDB/1.3.0 (Erlang OTP/R15B03)',
24 silly registry.get     etag: '"3IA0X8G22IP4MMXZ8J20SXA7A"',
24 silly registry.get     date: 'Sun, 21 Jul 2013 01:35:32 GMT',
24 silly registry.get     'content-length': '0' } ]
25 verbose etag onoff from cache
26 silly addNameRange number 2 { name: 'onoff', range: '*', hasData: true }
27 silly addNameRange versions [ 'onoff',
27 silly addNameRange   [ '0.0.1', '0.1.0', '0.1.2', '0.1.3', '0.1.4', '0.1.5', '0.1.6' ] ]
28 verbose addNamed [ 'onoff', '0.1.6' ]
29 verbose addNamed [ '0.1.6', '0.1.6' ]
30 silly lockFile df4262e7-onoff-0-1-6 onoff@0.1.6
31 verbose lock onoff@0.1.6 /Users/robbiewauters/.npm/df4262e7-onoff-0-1-6.lock
32 silly lockFile df4262e7-onoff-0-1-6 onoff@0.1.6
33 silly lockFile df4262e7-onoff-0-1-6 onoff@0.1.6
34 silly lockFile 0e81c0d2-onoff onoff@
35 silly lockFile 0e81c0d2-onoff onoff@
36 silly resolved [ { name: 'onoff',
36 silly resolved     version: '0.1.6',
36 silly resolved     description: 'GPIO based I/O and interrupt detection on the BeagleBone or Raspberry Pi',
36 silly resolved     main: 'onoff.js',
36 silly resolved     directories: { example: 'examples', test: 'test' },
36 silly resolved     scripts:
36 silly resolved      { test: 'echo "Tests can only be run manually from the command line. They access hardware GPIOs." && exit 1',
36 silly resolved        install: 'node-gyp rebuild' },
36 silly resolved     repository: { type: 'git', url: 'https://github.com/fivdi/onoff.git' },
36 silly resolved     engines: { node: '>=0.8.0' },
36 silly resolved     os: [ 'linux' ],
36 silly resolved     keywords:
36 silly resolved      [ 'gpio',
36 silly resolved        'embedded',
36 silly resolved        'interrupt',
36 silly resolved        'interrupts',
36 silly resolved        'beaglebone',
36 silly resolved        'beagle',
36 silly resolved        'bone',
36 silly resolved        'raspberry',
36 silly resolved        'raspi',
36 silly resolved        'rpi',
36 silly resolved        'pi',
36 silly resolved        'linux' ],
36 silly resolved     author: { name: 'fivdi' },
36 silly resolved     license: 'MIT',
36 silly resolved     gypfile: true,
36 silly resolved     readme: '## onoff\n\nGPIO based I/O and interrupt detection with Node.js on Linux boards such as the\nBeagleBone or Raspberry Pi.\n\nonoff provides a constructor function called Gpio which can be used to make\nGpio objects corresponding to Linux GPIOs. Examples of its usage can be seen in\nthe code below. The Gpio methods available are as follows:\n\n  * read(callback) - Read GPIO value asynchronously\n  * readSync() - Read GPIO value synchronously\n  * write(value, callback) - Write GPIO value asynchronously\n  * writeSync(value) - Write GPIO value synchronously\n  * watch(callback) - Watch and wait for GPIO to interrupt\n  * direction() - Read GPIO direction\n  * edge() - Read GPIO interrupt generating edge\n  * options() - Get GPIO options\n  * unexport() - Reverse the effect of exporting the GPIO to userspace\n\nGPIOs on Linux are identified by unsigned integers. These are the numbers that\nshould be passed to the onoff Gpio constructor function when exporting GPIOs\nto userspace. For example, pin P1_11 on the Raspberry Pi P1 expansion header\ncorresponds to GPIO #17 in Raspbian Linux. 17 is therefore the number to pass\nto the onoff Gpio constructor when using pin P1_11 on the P1 expansion header.\n\nonoff requires Node.js v0.8.0 or higher.\n\n## Installation\n\n    $ npm install onoff\n\n## Synchronous API - Blink the LED on GPIO #17 for 5 seconds\n\nThe examples here can be run by the superuser or by non-superusers when the\ntechnique described in section "How to handle superuser issues" is used.\n\n```js\nvar Gpio = require(\'onoff\').Gpio, // Constructor function for Gpio objects.\n    led = new Gpio(17, \'out\'),    // Export GPIO #17 as an output.\n    iv;\n\n// Toggle the state of the LED on GPIO #17 every 200ms.\n// Here synchronous methods are used. Asynchronous methods are also available.\niv = setInterval(function() {\n    led.writeSync(led.readSync() === 0 ? 1 : 0); // 1 = on, 0 = off :)\n}, 200);\n\n// Stop blinking the LED and turn it off after 5 seconds.\nsetTimeout(function() {\n    clearInterval(iv); // Stop blinking\n    led.writeSync(0);  // Turn LED off.\n    led.unexport();    // Unexport GPIO and free resources\n}, 5000);\n```\n\n## Asynchronous API - Blink the LED on GPIO #17 20 times\n\n```js\nvar Gpio = require(\'onoff\').Gpio, // Constructor function for Gpio objects.\n    led = new Gpio(17, \'out\');    // Export GPIO #17 as an output.\n\n// Toggle the state of the LED on GPIO #17 every 200ms \'count\' times.\n// Here asynchronous methods are used. Synchronous methods are also available.\n(function blink(count) {\n    if (count <= 0) return led.unexport();\n\n    led.read(function(err, value) {  // Asynchronous read.\n        if (err) throw err;\n\n        led.write(value === 0 ? 1 : 0, function(err) { // Asynchronous write.\n            if (err) throw err;\n        });\n    });\n\n    setTimeout(function() {\n        blink(count - 1);\n    }, 200);\n})(20);\n```\n\n## Wait for the button on GPIO #18 to interrupt\n\nThis example watches a momentary push button on GPIO #18 and prints a message\nwhen when the button is pressed interrupting the CPU. The watch method doesn\'t\nrequire CPU resources while waiting for an interrupt to occur freeing the CPU\nto perfrom other tasks.\n\n```js\nvar Gpio = require(\'onoff\').Gpio,        // Constructor function for Gpio objects.\n    button = new Gpio(18, \'in\', \'both\'); // Export GPIO #18 as an interrupt\n                                         // generating input.\n\nconsole.log(\'Please press the button on GPIO #18...\');\n\n// The callback passed to watch will be called when the button on GPIO #18 is\n// pressed. \nbutton.watch(function (err, value) {\n    if (err) throw err;\n\n    console.log(\'Button pressed!, its value was \' + value);\n\n    button.unexport(); // Unexport GPIO and free resources\n});\n```\n\n## How to handle superuser issues\n\nIn gereral, superuser privileges are required for exporting and using GPIOs.\nHowever, running all processes that access GPIOs as the superuser will be\nunacceptable for most. To resolve this issue onoff can be used as follows:\n\nStep 1 - Export GPIOs as superuser\n\nCreate a simple program for exporting GPIOs and execute this program with\nsuperuser privileges. In addition to exporting the GPIOs, this program will\nautomatically change the access permissions for the GPIOs value file giving\nall users read and write access.\n\n```js\nvar Gpio = require(\'onoff\').Gpio,\n    led = new Gpio(17, \'out\');\n```\n\nStep 2 - The application can be run by a non-superuser\n\nAfter the program from step one has been executed by the superuser, the\napplication itself can be executed by a non-superuser. The Gpio constructor\nwill see that the GPIO has already been exported to userspace and will not\nattempt to export it again. The value of the GPIO can be modified as all\nusers have read and write access to its value file.\n\nHighspeed Blinking\n\n```js\nvar Gpio = require(\'onoff\').Gpio,\n    led = new Gpio(17, \'out\'),\n    time = process.hrtime(),\n    hertz,\n    i;\n\nfor (i = 0; i !== 50000; i += 1) {\n    led.writeSync(1);\n    led.writeSync(0);\n}\n\ntime = process.hrtime(time);\nhertz = Math.floor(i / (time[0] + time[1] / 1E9));\n\nconsole.log(\'Frequency = \' + hertz / 1000 + \'KHz\');\n```\n\nDepending on the system load, the frequency logged to the console should be up\nto 35KHz on a 720MHz BeagleBone or up to 23KHz on a 700MHz Raspberry Pi.\n\nStep 3 - Unexport GPIOs as superuser\n\nAfter the application has terminated, a third program can be executed by the\nsuperuser to unexport the appropriate GPIOs.\n\n```js\nvar Gpio = require(\'onoff\').Gpio,\n    led = new Gpio(17, \'out\');\n\nled.unexport();\n```\n\n## How to watch five or more inputs\n\nonoff uses threads to watch and wait for GPIOs to interrupt. These threads are\nmanaged by Nodes libuv thread pool. The default size of this thread pool is\n[four on unix systems](https://github.com/joyent/libuv/blob/v0.10.8/src/unix/threadpool.c#L32).\nA thread is required for each GPIO being watched. If five or more GPIOs need to\nbe watched, the size of the libuv thread pool needs to be increased from four\nto at least five. With Node v0.10.x the thread pool size can be specified using\nthe [UV_THREADPOOL_SIZE](https://github.com/joyent/libuv/blob/v0.10.8/src/unix/threadpool.c#L99)\nenvironment variable. An example of the usage of UV_THREADPOOL_SIZE can be seen in\n[run-five-inputs](https://github.com/fivdi/onoff/blob/master/test/run-five-inputs)\nwhich runs [five-inputs](https://github.com/fivdi/onoff/blob/master/test/five-inputs.js)\nwith a thread pool size of ten.\n\n## Additional Information\n\nonoff has been tested on the BeagleBone (Ångström) and Raspberry Pi (Raspbian).\nThe suitability of onoff for a particular Linux board is highly dependent on\nhow GPIO interfaces are made available on that board. The\n[GPIO interfaces](http://www.kernel.org/doc/Documentation/gpio.txt)\ndocumentation describes GPIO access conventions rather than standards that must\nbe followed so GPIO can vary from platform to platform. For example, onoff\nrelies on sysfs files located at /sys/classes/gpio being available. However,\nthese sysfs files for userspace GPIO are optional and may not be available on a\nparticular platform.\n\n\n',
36 silly resolved     readmeFilename: 'README.md',
36 silly resolved     bugs: { url: 'https://github.com/fivdi/onoff/issues' },
36 silly resolved     _id: 'onoff@0.1.6',
36 silly resolved     _from: 'onoff@' } ]
37 info install onoff@0.1.6 into /Users/robbiewauters/Projects/SimonHuePi
38 info installOne onoff@0.1.6
39 error notsup Unsupported
39 error notsup Not compatible with your operating system or architecture: onoff@0.1.6
39 error notsup Valid OS:    linux
39 error notsup Valid Arch:  any
39 error notsup Actual OS:   darwin
39 error notsup Actual Arch: x64
40 error System Darwin 12.3.0
41 error command "node" "/usr/local/bin/npm" "install" "onoff"
42 error cwd /Users/robbiewauters/Projects/SimonHuePi
43 error node -v v0.10.13
44 error npm -v 1.3.2
45 error code EBADPLATFORM
46 verbose exit [ 1, true ]
